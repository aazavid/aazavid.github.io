<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <title>Конструирование ПО</title>

    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/blog.css" rel="stylesheet">
     <!-- Yandex.Metrika counter --> <script type="text/javascript" > (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter47238132 = new Ya.Metrika({ id:47238132, clickmap:true, trackLinks:true, accurateTrackBounce:true, webvisor:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks"); </script> <noscript><div><img src="https://mc.yandex.ru/watch/47238132" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter -->

   
  </head>

  <body>

     <nav class="navbar navbar-default navbar-fixed-top blog-nav">
      <div class="container"> 
        <ul class="nav navbar-nav">
        <li><a class="blog-nav-item" href="../index.html">Home</a></li>
        <li><a class="blog-nav-item" href="../base_main.html">Knowledge base</a></li>
        <li><a class="blog-nav-item" href="../about.html">About</a></li>
      </ul>
      </div>
    </nav>

    <div class="container">

      <div class="blog-header">
        <h1 class="blog-title">Конструирование ПО</h1>
        <blockquote class="blockquote">
            <p class="mb-0"> Конструирование ПО - создание работающего ПО с привлечением методов верификации, кодирования и тестирования компонентов. К инструментам конструирования ПО отнесены языки программирования и конструирования, а также программные методы и инструментальные системы (компиляторы, СУБД, генераторы отчетов, системы управления версиями, конфигурацией, тестированием и др.)
            </p>

        </blockquote>
       </p>
      </div>

      <div class="row">

        <div class="col-sm-12 blog-main">

          <div class="blog-post text-justify">
            
            <p class="blog-post-meta ">February 24, 2018 by </p>

            <p>Задачи конструирования:</p>
            <ul>
              <li>Написание ТЗ;</li>
              <li>Проектирование и написание классов и методов;</li>
              <li>Выбор типов данных(внутренних и внешних);</li>
              <li>Тестирование и отладка;</li>
              <li>Codereview;</li>
              <li>Документирование;</li>
              <li>Интерграция компонентов;</li>
              <li>Версионирование.</li>
            </ul>
            <p>Человеческий мозг не может удерживать более 7 объектов в один момент времени. Это влияет на все аспекты конструирования. Следует автоматизирвоть процессы верификации (проверки) и тестирования программных систем.</p>
            <p>Минимизация сложности достигается путем создания более простых модулей, прописывания простых и понятных рекомендаций в стандарте предприятия, собственном стандарте, либо стандарте языка. Тем самым мы уменьшаем порог входа. Следовательно, стоимость труда. Простой и легко читаемый код проще сопровождать на всех этапах конструирования. Его проще тестировать и проводить верификацию, сопровождать и вводить новый функционал.</p>
            <p>В случае сложного алгоритма необходимо локализовать сложные участки. Здесь хорошо подходит <b>объектно-ориентируемый подход</b>. Этот способ ограничивает интерфейс, инкапсулируя сложные участки внутри себя. Что упрощает взаимодействие разных объектов между собой и понимание системы в целом. Локализует все возможные ошибки в одном месте, чем упрощает тестирование системы.</p>
            
            <p>Конструирование зависит от <b>внешних стандартов</b>, связанных с языками программирования, используемым инструментальным обеспечением, техническими интерфейсами и взаимным влиянием Конструирования программного обеспечения и других областей знаний программной инженерии (в том числе, связанных дисциплин, например, управления проектами). Стандарты создаются разными источниками, например, консорциумом OMG – Object Management Group (в частности, стандарты CORBA, UML, MDA, …), международными организациями по стандартизации, такими как ISO/IEC, IEEE, TMF, …, производителями платформ, операционных сред и т.д. (например, Microsoft, Sun Microsystems, CISCO, NOKIA, …), производителями инструментов, систем управления базами данных ит.п. (Borland, IBM, Microsoft, Sun, Oracle, ...). Понимание этого факта позволяет определить достаточный и полный набор стандартов, применяемых в проектной команде или организации в целом.</p>
            <p>Определенные стандарты, соглашения и процедуры могут быть также созданы внутри организации или даже проектной команды. Эти стандарты поддерживают координацию между определенными видами деятельности, группами операций, минимизируют сложность (в том числе при взаимодействии членов проектной группы и за ее пределами), могут быть связаны с вопросами ожидания и обработки изменений, рисков и вопросами конструирования для проверки и дальнейшего тестирования.</p>
            <p>
              <img src="../img/managment_engenering.png"  class="img-responsive">
            </p>
            <h2>Модели конструирования<a name="1"></a></h2>
            <p>
              Модели конструирования определяют комплекс операций, связанные с общим жизненным циклом разработки. Некоторые стандарты жизненного цикла, по своей природе, являются ориентированными на конструирование – например, <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D1%81%D1%82%D1%80%D0%B5%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"><b>экстремальное программирование</b></a> (XP- eXtreme Programming). Некоторые рассматривают конструирование в неразрывной связи с проектированием (в части моделирования), например, <a href="https://ru.wikipedia.org/wiki/Rational_Unified_Process"><b>RUP</b></a> (Rational Unified Process).
            </p>
            <p>
              Некоторые модели являются более линейными с точки зрения конструирования ПО. К ним относятся, например, <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%81%D0%BA%D0%B0%D0%B4%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C"><b>водопадная</b></a> и <b>поэтапная</b> модели жизненного цикла. Эти модели рассматривают конструирование как деятельность, которая начинает проводиться только после завершения определенных обязательных к выполнению работ, включающих детальное определение требований, подробный дизайн и детальное планирование. Более линейные подходы стараются подчеркнуть действия, предваряющие конструирование (т.е. требования и дизайн) и создать более четкое разделение между такими различными типами деятельности. В таких моделях основным содержанием конструирования может быть <b>кодирование.</b></p>
            <p>
              Другие модели более итеративны, к ним относятся – <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F"><b>эволюционное прототипирование</b></a>, экстремальное программирование и <a href="https://ru.wikipedia.org/wiki/Scrum"><b>Scrum.</b></a> Эти подходы сходятся к рассмотрению конструирования как деятельности, которая ведется одновременно с другими видами работ по созданию программного обеспечения и пересекаясь с ними, включая определение требований, проектирование и планирование. Эти подходы смешивают проектирование, кодирование и тестирование, часто рассматривая их комбинацию как конструирование.
            </p>
            <h2>Планирование конструирования<a name="2"></a></h2>
            <p>
              Выбор метода (методологии) конструирования значим для всей конструкторской деятельности и необходимых условий ее осуществления, определяя порядок соответствующих операций и уровень выполнения заданных условий перед тем как начнется конструирование или составляющие его действия. Например, модульное тестирование в ряде методов является частью работ, после написания соответствующего функционального кода, в то время, как ряд гибких практик, например, XP требуют написания Unit-тестов до того, как пишется соответствующий код, требующий тестирования.
            </p>
            <p>
              Планирование конструкторской деятельности определяет порядок, в котором создаются компоненты и другие активы данной области знаний (фазы деятельности), проводятся работы по обеспечению качества получаемого программного обеспечения, распределяются задачи и соответствующие ресурсы, в том числе, определяются назначения/отображения работ конкретным инженерам-программистам, членам проектной группы. Все это, конечно, происходит, следуя правилам, определяемым используемым методом (методологией, практиками и т.п.).
            </p>
            <H2>Измерения в конструировании<a name="3"></a></H2>
            <p>
              Большая часть результатов, да и самой деятельности по конструированию программного обеспечения, может быть измерена, в том числе - количественно. Это и исходный разработанный код, и модифицированный объем кода, и степень повторного использования, и многие другие характеристики. Эти измерения, или как их еще принято называть – результаты аудита кода и метрики кода, несут большую пользу как для оценки рисков и качества так и для управления конструированием и программными проектами, в целом. 
            </p>
            <p>
              Последнее время, большое внимание многие профессиональные разработчики, то есть инженеры-конструкторы программного обеспечения, выделяют рефакторинг кода, как методы его реструктурирования, призванные без изменения содержания (то есть функциональности и функциональной целостности) обеспечить решение задач минимизации сложности, готовности к изменениям (гибкости), прозрачности документирования и многих других актуальных аспектов конструирования. Применение измерений, в частности, метрик, позволяет определить необходимость внесения таких изменений, проведения <b>рефакторинга.</b> 
            </p>
            <H2>Проектирование в конструировании<a name="4"></a></H2>
           
            <p>
              Вне зависимости от четкости выделения деятельности по проектированию, как таковой, практически всегда на стадии конструирования приходится заниматься и вопросами детального дизайна системы. 
            </p>
            <p>
              Детали деятельности по проектированию на стадии конструирования в основном те же самые, что и описанные в области знаний <a href="software_design.html">“Проектирование программного обеспечения” (Software Design).</a> Отличие заключается в большем внимании деталям.
            </p>
            <H2>Языки конструирования<a name="5"></a></H2>
            <p>
              Языки конструирования включают все формы коммуникаций, с помощью которых человек может задать решение проблемы, выполняемое на компьютере.
            </p>
            <p>
              Простейший тип языков конструирования – <i><b>конфигурационный язык</b></i> (configuration language), позволяющий задавать параметры выполнения программной системы.
            </p>
            <p>
              <i><b>Инструментальный язык</b></i> – язык конструирования из повторно-используемых элементов (обычно строится как сценарный язык), выполняемый в соответствующей среде.
            </p>
            <p>
              <i><b>Язык программирования</b></i> – наиболее гибкий тип языков конструирования. Содержит минимальный объем информации о конкретных областях приложения и процессе разработки, требуя больше всего усилий на изучение и наработку опыта для эффективного применения при решении конкретных задач.
            </p>
            <p>
              Существует три основных вида нотаций используемых при определении языков программирования:
              <ul>
                <li>Лингвистическая</li>
                <li>Формальная</li>
                <li>Визуальная</li>
              </ul>
            </p>
            <p>
              <i><b>Лингвистические нотации</b></i> характеризуются, в частности, использованием строк текста, содержащих специализированные “слова”, представляющие сложные программные конструкции, и комбинируемые в шаблоны, напоминающие предложения, построенные в соответствии с определенным синтаксисом. В случае корректного использования таких нотаций, каждая получаемая строка обладает строгой смысловой нагрузкой (<b>семантикой</b>), обеспечивающей интуитивное понимание того, что будет происходить, когда будет выполняться программное обеспечение, построенное с использованием такого языка конструирования.
            </p>
            <p>
              <i><b>Формальные нотации</b></i> являются менее интуитивными, чем лингвистические, и часто базируются на точных формальных (математических) определениях. Формальные нотации конструкций и формальные методы являются ядром практически всех форм системного программирования, точнее – поведения систем во времени. Такие нотации обеспечивают наибольшую готовность получаемого кода к тестированию, что намного важнее, чем просто возможность отображения на обычный человеческий язык. Формальные конструкции также используют точный метод определения комбинаций применяемых символов, что позволяет избежать неоднозначностей, присущих конструкциям естественных языков.
            </p>
            <p>
              <i><b>Визуальные нотации</b></i> наименее связаны с текстово-ориентированными подходами, предполагая непосредственную интерпретацию визуальных конструкций в процессе исполнения описываемой логики. При этом логика в визуальных нотациях задается расположением соответствующих визуальных сущностей, ответственных за те или иные операции и структуры данных.
            </p>
            <p>
              Сегодняшние работы (и их состояние) в области архитектур и приложений, управляемых моделями, в первую очередь - OMG MDA (<a href="www.omg.org/mda">Model-Driven Architecture</a>), UML (<a href="www.omg.org/uml">Unified Modeling Language</a>), Microsoft DSL (Domain-Specific Language), направлены на то, чтобы использовать ту или иную визуальную нотацию, базирующуюся на мета-моделях, в качестве инструмента, применяемого и для определения функциональной логики системы. 
            </p>
            <p>
              Другая область стандартов, направленных на применение визуальных нотаций для описания функциональности – Business Process Management Notation (<a href="www.omg.org/bpmn">BPMN</a>) и связанный с ней язык Business Process Execution Language, построенный на базе XML. Таким образом, область обоснованного применения визуальных нотаций для конструирования программных систем качественно расшириться и, не исключено, мы станем свидетелями de-facto формирования новой категории нотаций, соглашений и смешанных типов языковых средств, предназначенных для конструирования программного обеспечения как естественного продолжения проектирования.
            </p>
            <H2>Кодирование<a name="6"></a></H2>
            <p>
              Практика конструирования программного обеспечения показывает активное применение следующих соображений и техник:
              <ul>
                <li>техники создания легко понимаемого исходного кода на основе использования соглашений об именовании, форматирования и структурирования кода;</li>
                <li>использование классов, перечисляемых типов, переменных, именованных констант и других выразительных сущностей;</li>
                <li>организация исходного текста (в процедуры и функции, <a href="software_templates.html">шаблоны проектирования</a>, классы, пакеты/модули и другие структуры);</li>
                <li>обработка ошибочных условий и исключительных ситуаций, предотвращение возможных брешей в безопасности (например, переполнение буфера или выход за пределы индекса в массиве);</li>
                <li>использование ресурсов на основе применения механизмов исключения (из рассмотрения) и порядка доступа к параллельно используемым ресурсам (например, на основе блокировки данных, использования потоков и их синхронизации и т.п.);</li>
                
              </ul>
            </p>
            <H2>Тестирование в конструировании<a name="7"></a></H2>
            <p>
              При конструировании используются две формы тестирования, проводимого инженерами, непосредственно создающими исходный код:
              <ul>
                <li>модульное тестирование</li>
                <li>интеграционное тестирование</li>
              </ul>
            </p>
            <p>
              Главная цель тестирования в конструировании уменьшить временной разрыв между моментом проявления ошибок, имеющихся в коде, и моментом их обнаружения. Во многих случаях, тестирование в конструировании производится после того, как код написан. В ряде случаев, тесты пишутся до того, как создается код(<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">TDD</a>).
            </p>
            <p>
              Тестирование в конструировании обычно включает подмножество тестовых методик, описанных в области знаний “Тестирование программного обеспечения” (<a href="software_testing.html">Software Testing</a>). Например, тестирование в конструировании обычно не включает системного тестирования, нагрузочного тестирования, usability-тестирования (оценки прозрачности использования) и других видов тестовой деятельности.
            </p>
            <h2>Повторное использование<a name="8"></a></h2>
            <p>
              Задачи, связанные с повторным использованием в процессе конструирования и тестирования, включают:
              <ul>
                <li>выбор единиц, баз данных тестовых процедур, данных полученных в результате тестов и самих тестов, подлежащих повторному использованию;</li>
                <li>оценку потенциала повторного использования кода и тестов;</li>
                <li>отслеживание информации и создание отчетности по повторному использованию в новом коде, тестовых процедурах и данных, полученных в результате тестов.</li>
              </ul>
            </p>
            <h2>Качество конструирования<a name="9"></a></h2>
            <p>
              Существует ряд техник, предназначенных для обеспечения качества кода, выполняемых по мере его конструирования. Основные техники обеспечения качества, используемые в процессе конструирования, включают:
              <ul>
                <li>модульное и интеграционное тестирование</li>
                <li>разработка с первичностью тестов (тесты пишутся до конструирования кода)</li>
                <li>пошаговое кодирование (деятельность по конструированию кода разбивается на мелкие шаги, только после тестирования результатов, которых производится переход к следующему шагу кодирования; известен также как итеративное кодирование с тестированием)</li>
                <li>использование процедур утверждений</li>
                <li>отладка</li>
                <li>технические обзоры и оценки</li>
                <li>статический анализ</li>              
              </ul>
            </p>
            <p>
              Выбор и использование конкретных техник часто диктуется стандартами (внутренними и внешними), используемыми проектной командой, а также зависят от опыта и подготовленности специалистов, занимающихся конструированием кода.
            </p>
            <p>
              Деятельность по обеспечению качества в конструировании отличается от других операций по обеспечению качества. Основное отличие заключается в фокусе на программном (исходном) коде и других артефактах (активах), тесно связанных с кодом, в частности, детальных моделях.
            </p>
            <H2>Интеграция<a name="10"></a></H2>
            <p>
              Одна из ключевых деятельностей, осуществляемых в процессе конструирования, - интеграция отдельно сконструированных операций (процедур), классов, компонентов и подсистем (модулей). В дополнение к этому, некоторые программные системы нуждаются в специальной интеграции с другим программным и аппаратным обеспечением.
            </p>
            <p>
              Кроме упомянутых аспектов интеграции, к обсуждаемым интеграционным вопросам конструирования относятся:
              <ul>
                <li>планирование последовательности, в которой интегрируются компоненты;</li>
                <li>обеспечение поддержки создания промежуточных версий программного обеспечения;</li>
                <li>задание “глубины” тестирования (в частности, на основе критериев “приемлемого” качества) и других работ по обеспечению качества интегрируемых в дальнейшем компонент;</li>
                <li>наконец, определение этапных точек проекта, когда будут тестироваться промежуточные версии конструируемой программной системы.</li>
              </ul>
            </p>
            <hr>
            <H3>Ссылки</H3>
            <hr>
            <ol>
              <li><a href="https://www.intuit.ru/studies/courses/2190/237/lecture/6118?page=2">Курс на Интуите: Академия Microsoft: Методы и средства инженерии программного обеспечения. Лекция 2: Области знаний программной инженерии и стандарты ЖЦ программного обеспечения</a></li>
              <li><a href="http://www.4stud.info/software-construction-and-testing/lecture3.html">УЧЕБНО-МЕТОДИЧЕСКИЕ МАТЕРИАЛЫ ДЛЯ СТУДЕНТОВ КАФЕДРЫ АСОИУ</a></li>
              <li>IEEE Std. 1517-99 “IEEE Standard for Information Technology – Software Lifecycle Process – Reuse Processes” </li>
              <li>IEEE Std 829-1998: “IEEE Standard for Software Test Documentation”</li>
              <li>IEEE Std 1008-1987: “IEEE Standard for Software Unit Testing”.</li>
            </ol>
            
          </div><!-- /.blog-post -->

          <script src="//yastatic.net/es5-shims/0.0.2/es5-shims.min.js"></script>
          <script src="//yastatic.net/share2/share.js"></script>
          <div class="ya-share2" data-services="vkontakte,facebook,gplus,evernote,linkedin,lj,pocket,telegram" data-counter="">
          </div>


          <ul class="pager">
            <li><a href="../base_main.html">Previous</a></li>
            <li><a href="software_design.html">Next</a></li>
          </ul>

        </div><!-- /.blog-main -->
   <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="../../../dist/js/bootstrap.min.js"></script>
    <script src="../../../assets/js/docs.min.js"></script>
  </body>
</html>